"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildSKMultiple = exports.deriveMasterSK = exports.deriveChildSK = void 0;
const hkdf_1 = require("@noble/hashes/hkdf");
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
function ikmToLamportSK(ikm, salt) {
    const okm = hkdf_1.hkdf(sha256_1.sha256, ikm, salt, new Uint8Array(0), 8160); // 8160 = 255 * 32
    return Array.from({ length: 255 }, (_, i) => okm.slice(i * 32, (i + 1) * 32));
}
function parentSKToLamportPK(parentSK, index) {
    const salt = new Uint8Array(4);
    new DataView(salt.buffer).setUint32(0, index, false);
    const ikm = parentSK;
    const lamport0 = ikmToLamportSK(ikm, salt);
    const notIkm = Uint8Array.from(ikm.map((value) => ~value));
    const lamport1 = ikmToLamportSK(notIkm, salt);
    const lamportPK = lamport0.concat(lamport1).map((value) => sha256_1.sha256(value));
    return sha256_1.sha256(utils_1.concatBytes(...lamportPK));
}
function hkdfModR(ikm, keyInfo = new Uint8Array(0)) {
    let salt = utils_1.utf8ToBytes("BLS-SIG-KEYGEN-SALT-");
    let sk = BigInt(0);
    while (sk === BigInt(0)) {
        salt = sha256_1.sha256(salt);
        const okm = hkdf_1.hkdf(sha256_1.sha256, utils_1.concatBytes(ikm, new Uint8Array(1)), salt, utils_1.concatBytes(keyInfo, Uint8Array.from([0, 48])), 48);
        const okmBN = BigInt("0x" + utils_1.bytesToHex(okm));
        const r = BigInt("52435875175126190479447740508185965837690552500527637822603658699938581184513");
        sk = okmBN % r;
    }
    return utils_1.hexToBytes(sk.toString(16).padStart(64, "0"));
}
function deriveChildSK(parentSK, index) {
    if (!(parentSK instanceof Uint8Array) || parentSK.length !== 32) {
        throw new Error("parentSK must be a Uint8Array of 32 bytes");
    }
    if (!Number.isSafeInteger(index) || index < 0 || index >= 2 ** 32) {
        throw new Error("index must be 0 <= i < 2**32");
    }
    const compressedLamportPK = parentSKToLamportPK(parentSK, index);
    return hkdfModR(compressedLamportPK);
}
exports.deriveChildSK = deriveChildSK;
function deriveMasterSK(ikm) {
    if (!(ikm instanceof Uint8Array)) {
        throw new Error("ikm must be a Uint8Array");
    }
    if (ikm.length < 32) {
        throw new Error("ikm must be >= 32 bytes");
    }
    return hkdfModR(ikm);
}
exports.deriveMasterSK = deriveMasterSK;
function deriveChildSKMultiple(parentSK, indices) {
    let key = parentSK;
    indices.forEach(i => key = deriveChildSK(key, i));
    return key;
}
exports.deriveChildSKMultiple = deriveChildSKMultiple;
//# sourceMappingURL=key-derivation.js.map