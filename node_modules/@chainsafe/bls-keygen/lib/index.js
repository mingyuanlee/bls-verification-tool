"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveEth2ValidatorKeys = exports.eth2ValidatorPaths = exports.deriveKeyFromMaster = exports.deriveKeyFromEntropy = exports.deriveKeyFromMnemonic = exports.generateRandomSecretKey = void 0;
const bip39_1 = require("@scure/bip39");
const english_1 = require("@scure/bip39/wordlists/english");
const utils_1 = require("@noble/hashes/utils");
const bls_hd_key_1 = require("@chainsafe/bls-hd-key");
/**
 *
 * @param entropy optional additional entropy
 */
function generateRandomSecretKey(entropy) {
    let ikm = utils_1.randomBytes(32);
    if (entropy) {
        ikm = utils_1.concatBytes(entropy, ikm);
    }
    return deriveKeyFromEntropy(ikm);
}
exports.generateRandomSecretKey = generateRandomSecretKey;
/**
 * Derive a secret key from a BIP39 mnemonic seed and optionally an EIP-2334 path.
 * If path is included, the derived key will be the child secret key at that path,
 * otherwise, the derived key will be the master secret key
 */
function deriveKeyFromMnemonic(mnemonic, path) {
    if (!bip39_1.validateMnemonic(mnemonic, english_1.wordlist)) {
        throw new Error("invalid mnemonic");
    }
    const ikm = Uint8Array.from(bip39_1.mnemonicToSeedSync(mnemonic));
    return deriveKeyFromEntropy(ikm, path);
}
exports.deriveKeyFromMnemonic = deriveKeyFromMnemonic;
/**
 * Derive a secret key from entropy and optionally an EIP-2334 path.
 * If path is included, the derived key will be the child secret key at that path,
 * otherwise, the derived key will be the master secret key
 */
function deriveKeyFromEntropy(entropy, path) {
    const masterKey = bls_hd_key_1.deriveMasterSK(Uint8Array.from(entropy));
    if (path) {
        return deriveKeyFromMaster(masterKey, path);
    }
    return masterKey;
}
exports.deriveKeyFromEntropy = deriveKeyFromEntropy;
/**
 * Derive a child secret key from a master secret key
 * @param masterKey master secret key
 * @param path EIP-2334 path to child
 */
function deriveKeyFromMaster(masterKey, path) {
    return bls_hd_key_1.deriveChildSKMultiple(masterKey, bls_hd_key_1.pathToIndices(path));
}
exports.deriveKeyFromMaster = deriveKeyFromMaster;
/**
 * Return Eth2 validator HD paths
 */
function eth2ValidatorPaths(validatorIndex) {
    return {
        withdrawal: `m/12381/3600/${validatorIndex}/0`,
        signing: `m/12381/3600/${validatorIndex}/0/0`,
    };
}
exports.eth2ValidatorPaths = eth2ValidatorPaths;
/**
 * Derive Eth2 validator secret keys from a single master secret key
 * @param masterKey master secret key
 */
function deriveEth2ValidatorKeys(masterKey, validatorIndex) {
    const paths = eth2ValidatorPaths(validatorIndex);
    return {
        withdrawal: deriveKeyFromMaster(masterKey, paths.withdrawal),
        signing: deriveKeyFromMaster(masterKey, paths.signing),
    };
}
exports.deriveEth2ValidatorKeys = deriveEth2ValidatorKeys;
//# sourceMappingURL=index.js.map